# Copyright 2024 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate a dataset of spin configurations as blobs."""

import numpy as np


class RandomSpinBlobs:
    """Generate spin configurations with high probabilites for certain spins.

    The dataset is generated by creating random spin samples close to a few
    chosen `peak_spin` configurations of dimension `N` with each spin having
    the possible values 0 or 1. We can vary the `peak_probabilities` parameter
    to create data with different modes, where some samples will have higher
    probabilities allowing us to study the effects of imbalance in the data.

    Samples are generated by selecting one of the peak spin configurations
    distributed according `peak_probabilities`, and then by flipping some of the
    spins. The number of spins that are flipped each time, is drawn from a
    Binomial distribution bin(`N`, `p`) where `p=1` will flip all the spins
    and `p=0` will not flip any spins therefore creating very narrow distributions
    around the peak spins.

    Args:
        N (int): The number of spins.
        num_blobs (int):
            The number of blobs or peak probabilities.
        peak_probabilities (list[float], optional):
            The probability of each spin to be selected. If not specified,
            the probabilities are distributed uniformly.
        peak_spins (list[np.array], optional):
            The peak spin configurations. Selected randomly by default.
        p (float, optional):
            The value of the parameter `p` in a Binomial distribution specifying
            the number of spins that are flipped each time during sampling.
            Defaults to 0.01.
    """

    def __init__(
        self,
        N: int,
        num_blobs: int,
        peak_probabilities: list[float] = None,
        peak_spins: list[np.array] = None,
        p: float = 0.01,
    ) -> None:
        self.N = N
        self.num_blobs = num_blobs

        if peak_probabilities is None:
            peak_probabilities = [1 / num_blobs for i in range(num_blobs)]

        if len(peak_probabilities) != num_blobs:
            msg = f"Specify probabilities for all {num_blobs} blobs."
            raise ValueError(msg)

        if peak_spins is not None and len(peak_spins) != num_blobs:
            msg = f"The number of peak spins should be the same as blobs."
            raise ValueError(msg)

        if peak_spins is None:
            # generate some random peak spin configs
            # we flip each bit with 50% prob
            spin_configs = []
            while len(spin_configs) < num_blobs:
                config = list((-1) ** np.random.binomial([1] * N, [0.5] * N))
                if config not in spin_configs:
                    spin_configs.append(config)
            peak_spins = spin_configs

        self.peak_spins = peak_spins
        self.peak_probabilities = peak_probabilities
        self.p = p

    def sample(self, n_samples: int, return_labels=False) -> np.array:
        """Generate a given number of samples.

        Args:
            n_samples (int): Number of samples to generate.
            return_labels (bool, optional):
                Whether to return labels for each sample. Defaults to False.

        Returns:
            np.array: A (n_samples, N) array of spin configurations.
        """
        samples = []
        labels = []

        for _ in range(n_samples):
            # Choose a random peak
            label = np.random.choice(self.num_blobs, p=self.peak_probabilities)
            labels.append(label)
            peak_spin = self.peak_spins[label]

            # Randomly choose a Hamming distance from the sampler
            num_bits_to_flip = np.random.binomial(self.N, self.p)

            # Flip bits randomly in the peak spin configuration
            indices_to_flip = np.random.choice(self.N, num_bits_to_flip, replace=False)
            sampled_spin = np.copy(peak_spin)
            for index in indices_to_flip:
                sampled_spin[index] *= -1

            samples.append(sampled_spin)

        samples = (np.array(samples) + 1) / 2

        if return_labels:
            return samples, np.array(labels)
        else:
            return samples


def generate_8blobs(
    n_samples: int,
    p: float = 0.01,
):
    """Generate 4x4 spin samples with 8 selected high-probability configurations

    Example
    -------
        import matplotlib.pyplot as plt
        from qml_benchmarks.data.spin_blobs import generate_8blobs
        X, y = generate_8blobs(100)
        n_samples = 20
        interval = len(X) // n_samples

        fig, axes = plt.subplots(1, n_samples, figsize=(20, 4))
        for i in range(n_samples):
            axes[i].imshow(X[i*interval].reshape((4, 4)))
            axes[i].axis('off')
        plt.show()

    Args:
        n_samples (int): The number of samples to generate.
        p (float, optional):
            The value of the parameter p in a Binomial distribution bin(N, p)
            that determines how many spins are flipped during each sampling step
            after choosing one of the peak configurations. Defaults to 0.01.

    Returns:
        np.ndarray: A (n_samples, 16) array of spin configurations.
    """
    np.random.seed(66)
    N: int = 16
    num_blobs: int = 8

    # generate a specific set
    config1 = np.array(
        [[1, 1, -1, -1], [1, 1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]
    )
    config2 = np.array(
        [[-1, -1, 1, 1], [-1, -1, 1, 1], [-1, -1, -1, -1], [-1, -1, -1, -1]]
    )
    config3 = np.array(
        [[-1, -1, -1, -1], [-1, -1, -1, -1], [1, 1, -1, -1], [1, 1, -1, -1]]
    )
    config4 = np.array(
        [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, 1, 1], [-1, -1, 1, 1]]
    )
    config5 = np.array(
        [[-1, -1, -1, -1], [-1, 1, 1, -1], [-1, 1, 1, -1], [-1, -1, -1, -1]]
    )
    config6 = np.array(
        [[1, -1, -1, -1], [-1, 1, -1, -1], [-1, -1, 1, -1], [-1, -1, -1, 1]]
    )
    config7 = np.array(
        [[-1, -1, -1, 1], [-1, -1, 1, -1], [-1, 1, -1, -1], [1, -1, -1, -1]]
    )
    config8 = np.array(
        [[1, -1, -1, 1], [-1, -1, -1, -1], [-1, -1, -1, -1], [1, -1, -1, 1]]
    )

    peak_spins = [
        np.reshape(config1, -1),
        np.reshape(config2, -1),
        np.reshape(config3, -1),
        np.reshape(config4, -1),
        np.reshape(config5, -1),
        np.reshape(config6, -1),
        np.reshape(config7, -1),
        np.reshape(config8, -1),
    ]
    sampler = RandomSpinBlobs(
        N=N,
        num_blobs=num_blobs,
        peak_spins=peak_spins,
        p=p,
    )

    X, y = sampler.sample(n_samples=n_samples, return_labels=True)
    X = X.reshape(-1, N)

    return X, y

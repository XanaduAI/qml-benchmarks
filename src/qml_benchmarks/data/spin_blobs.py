# Copyright 2024 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate a dataset of spin configurations as blobs."""

import numpy as np


class RandomSpinBlobs:
    """Generate spin configurations with high probabilites for certain spins.

    The dataset is generated by creating random spin samples close to a few
    chosen peaks forming a set of blobs. One of the peaks is chosen randomly
    and then by flipping some of the spins from the chosen configuration, new
    spins are added so that they are a certain hamming distance away from the
    chosen peak chosen from a binomial distribution with a certain noise.

    Args:
        N (int): The number of spins.
        num_blobs (int): The number of blobs or peak probabilities.
        peak_probabilities (list[float], optional):
            The probability of each spin to be selected. If not specified,
            the probabilities are distributed uniformly.
        peak_spins (list[np.array], optional):
            The peak spin configurations, selected randomly by default.
        noise_probability (float, optional):
            The probability with which a binomial distribution is sampled to
            add noise to the spin configurations.
    """

    def __init__(
        self,
        N: int,
        num_blobs: int,
        peak_probabilities: list[float] = None,
        peak_spins: list[np.array] = None,
        noise_probability: float = 0.001,
    ) -> None:
        self.N = N
        self.num_blobs = num_blobs

        if peak_probabilities is None:
            peak_probabilities = [1 / num_blobs for i in range(num_blobs)]

        if len(peak_probabilities) != num_blobs:
            msg = f"Specify probabilities for all {num_blobs} blobs."
            raise ValueError(msg)

        if peak_spins is not None and len(peak_spins) != num_blobs:
            msg = f"The number of peak spins should be the same as blobs."
            raise ValueError(msg)

        if peak_spins is None:
            # generate some random peak spin configs
            # we flip each bit with 50% prob
            spin_configs = []
            while len(spin_configs) < num_blobs:
                config = list((-1) ** np.random.binomial([1] * N, [0.5] * N))
                if config not in spin_configs:
                    spin_configs.append(config)
            peak_spins = spin_configs

        self.peak_spins = peak_spins
        self.peak_probabilities = peak_probabilities
        self.noise_probability = noise_probability

    def sample(self, num_samples: int, return_labels=False) -> np.array:
        """Generate a given number of samples.

        Args:
            num_samples (int): Number of samples to generate.
            return_labels (bool, optional):
                Whether to return labels for each sample. Defaults to False.

        Returns:
            np.array: A (num_samples, N) array of spin configurations.
        """
        samples = []
        labels = []

        for _ in range(num_samples):
            # Choose a random peak
            label = np.random.choice(self.num_blobs, p=self.peak_probabilities)
            labels.append(label)
            peak_spin = self.peak_spins[label]

            # Randomly choose a Hamming distance from the sampler
            dist = np.random.binomial(self.N, self.noise_probability)

            # Flip 'dist' number of bits randomly in the peak spin configuration
            indices_to_flip = np.random.choice(self.N, dist, replace=False)
            sampled_spin = np.copy(peak_spin)
            for index in indices_to_flip:
                sampled_spin[index] *= -1

            samples.append(sampled_spin)

        if return_labels:
            return np.array(samples), np.array(labels)
        else:
            return np.array(samples)